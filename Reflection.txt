
1. One time and space efficiency limitation with my code is the algorithm I implement in minimax. I decided to  use an Array List to represent the scores because that is what makes the most sense to me conceptually, but it is not the most efficient use of time or space. For example, if the game was being played with 100 pieces, the score for every possible state would have to be added to the array list. The list would have more elements and therefore take up more space, but there would be a larger effect on the efficiency of the program, because the code would have to continuously be resizing the array list in order to add the scores of each state, which would take up run time. 

2. No, my bot will not win every possible game of SimpleNim. This is because there are just some instances where it is impossible for a certain player to win. For example, if there are 5 pieces left and it is your turn, taking any number of pieces (1, 2, or 3) would result in a state where your opponent would be able to win no matter what. The minimax algorithm finds the best score for both players, and since bestMove considers the next state (which is when it is the other player's turn), there will be times when the bot is unable to produce the best result for you. The algorithm still produces the best strategy for the other player and allows them to win, but you will not win in every instance

3. If the goal of Nim became taking the last piece, the strategy would more or less flip. First off, in lines 40-44, the base case would need to be changed so that if there were 0 pieces left and it was your turn, -1 would be returned because that situation means you lost. In terms of scoring, player X could still maximize and player Y could still minimize, so the algorithm for calculating the scores could remain the same. In bestMove, you would still want to use similar logic by checking if the next state is favorable for a player. Now that the base case in minimax would be different, bestMove would take that into account when calling the function, and calls that were favorable for player X in Nim will be unfavorable in AntiNim. 

4.I do not think my algorithm would work well on games with a larger degree of difficulty and complexity, such as chess. Particularly, I think it would be challenging for my algorithm to work on a chess game because in chess there is the added layer of direction that the pieces are moving, and my code does not account for that. I think I could use similar logic to find states of the game and their benefits for the players, but when it comes to actually finding the best move (what direction to move the pieces in), I would need to adapt my code. There are many more pieces in chess and more options of where they could move. Currently, my code only accounts for the movement of 3 or less pieces, so it would need to be more robust in order to work for more complicated games such as chess. 